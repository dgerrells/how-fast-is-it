use minifb::{Key, MouseButton, Window, WindowOptions};
use rand::Rng;
use std::sync::mpsc;
use std::thread;
use std::time::Instant;

const WIDTH: usize = 1200;
const HEIGHT: usize = 800;
const PARTICLE_COUNT: usize = 20_000_000;
const THREAD_COUNT: usize = 8;
const PARTICLE_STRIDE: usize = 4;
const GRAVITY_STRENGTH: f32 = 200.5;
const MAX_PERF_SAMPLE_FRAMES: usize = 100;

fn main() {
    let mut particles: Box<[f32]> = vec![0.0; PARTICLE_COUNT * PARTICLE_STRIDE].into_boxed_slice();

    let mut rng = rand::thread_rng();
    let mut buffer: Vec<u32> = vec![0; WIDTH * HEIGHT];
    let mut p_count_buffer = vec![0 as u8; WIDTH * HEIGHT];
    let mut window = Window::new("Safu", WIDTH, HEIGHT, WindowOptions::default()).unwrap_or_else(|e| {
        panic!("{}", e);
    });
    window.set_target_fps(120);

    let mut i: usize = 0;
    while i < PARTICLE_COUNT {
        let idx = i * PARTICLE_STRIDE;
        particles[idx] = rng.gen_range(0.0..WIDTH as f32);
        particles[idx + 1] = rng.gen_range(0.0..HEIGHT as f32);
        particles[idx + 2] = rng.gen_range(-1.0..1.0);
        particles[idx + 3] = rng.gen_range(-1.0..1.0);
        i += 1;
    }

    let mut mouse_pos = (WIDTH as f32 / 2.0, HEIGHT as f32 / 2.0);
    let mut mouse_pressed = false;
    let friction_per_second = 0.99_f32.powf(60.0);

    let mut frame_count = 0;
    let mut last_fps_time = Instant::now();
    let mut last_frame_time = Instant::now();
    let mut simulation_times = vec![];
    let mut drawing_times = vec![];
    let mut fps = 0;

    while window.is_open() && !window.is_key_down(Key::Escape) {
        let now = Instant::now();
        let delta_time = now.duration_since(last_frame_time).as_secs_f32();
        last_frame_time = now;

        let sim_start = Instant::now();

        if let Some((mx, my)) = window.get_mouse_pos(minifb::MouseMode::Clamp) {
            mouse_pos = (mx, my);
        }
        mouse_pressed = window.get_mouse_down(MouseButton::Left);

        let (tx, rx) = mpsc::channel();
        let chunk_size = PARTICLE_COUNT / THREAD_COUNT;
        let particles_ptr = particles.as_mut_ptr();

        for t in 0..THREAD_COUNT {
            let tx = tx.clone();
            let mouse_pos = mouse_pos;
            let mut buffer = vec![0 as u8; WIDTH * HEIGHT];

            let start = t * chunk_size * PARTICLE_STRIDE;
            let end = if t == THREAD_COUNT - 1 {
                PARTICLE_COUNT * PARTICLE_STRIDE
            } else {
                (t + 1) * chunk_size * PARTICLE_STRIDE
            };

            unsafe {
                let particles_chunk = std::slice::from_raw_parts_mut(particles_ptr.add(start), end - start);

                thread::spawn(move || {
                    for particle in particles_chunk.chunks_mut(PARTICLE_STRIDE) {
                        if mouse_pressed {
                            let dx = mouse_pos.0 - particle[0];
                            let dy = mouse_pos.1 - particle[1];
                            let distance = dx * dx + dy * dy;

                            if distance > 2.0 {
                                let inv_gravity = GRAVITY_STRENGTH / distance.sqrt();
                                particle[2] += dx * inv_gravity * 8.0 * delta_time;
                                particle[3] += dy * inv_gravity * 8.0 * delta_time;
                            }
                        }

                        let friction = friction_per_second.powf(delta_time);
                        particle[2] *= friction;
                        particle[3] *= friction;
                        particle[0] += particle[2] * delta_time;
                        particle[1] += particle[3] * delta_time;

                        let x = particle[0] as usize;
                        let y = particle[1] as usize;
                        if x >= WIDTH || y >= HEIGHT || x <= 0 || y <= 0 {
                            continue;
                        }

                        let buffer_index = y * WIDTH + x;
                        let p_count = buffer[buffer_index];
                        buffer[buffer_index] = p_count.saturating_add(1);
                    }

                    tx.send(buffer).unwrap();
                });
            }
        }
        
        drop(tx);
        p_count_buffer.iter_mut().for_each(|c| *c = 0);
        for local_buffer in rx {
            for (i, &count) in local_buffer.iter().enumerate() {
                p_count_buffer[i] = p_count_buffer[i].saturating_add(count);
            }
        }

        simulation_times.push(sim_start.elapsed().as_secs_f32());
        if simulation_times.len() > MAX_PERF_SAMPLE_FRAMES {
            simulation_times.remove(0);
        }

        let draw_start = Instant::now();
        buffer.iter_mut().for_each(|pixel| *pixel = 0);
        for (i, &count) in p_count_buffer.iter().enumerate() {
            let x = i % WIDTH;
            let y = i / WIDTH;
            let r = (x as f32 / WIDTH as f32 * 12.0 * count as f32) as u8;
            let g = (y as f32 / HEIGHT as f32 * 12.0 * count as f32) as u8;
            let b = (10.0 * count as f32) as u8;

            buffer[i] = ((r as u32) << 16) | ((g as u32) << 8) | (b as u32);
        }

        window.update_with_buffer(&buffer, WIDTH, HEIGHT).unwrap();

        drawing_times.push(draw_start.elapsed().as_secs_f32());
        if drawing_times.len() > MAX_PERF_SAMPLE_FRAMES {
            drawing_times.remove(0);
        }

        frame_count += 1;
        if now.duration_since(last_fps_time).as_secs_f32() >= 1.0 {
            fps = frame_count;
            frame_count = 0;
            last_fps_time = now;

            let avg_simulation_time: f32 =
                simulation_times.iter().sum::<f32>() / simulation_times.len() as f32;
            let avg_drawing_time: f32 =
                drawing_times.iter().sum::<f32>() / drawing_times.len() as f32;

            println!("FPS: {}", fps);
            println!("Avg Simulation Time: {:.5}", avg_simulation_time * 1000.0);
            println!("Avg Drawing Time: {:.5}", avg_drawing_time * 1000.0);
        }
    }
}