use minifb::{Key, MouseButton, Window, WindowOptions};
use rand::Rng;
use std::time::Instant;

const WIDTH: usize = 1200;
const HEIGHT: usize = 800;
const PARTICLE_COUNT: usize = 5_000_000;
const GRAVITY_STRENGTH: f32 = 205.5*8.0;
#[repr(align(16))]
struct Particle {
    x: f32,
    y: f32,
    dx: f32,
    dy: f32,
}

fn generate_particles(count: usize, width: usize, height: usize) -> Vec<Particle> {
    let mut rng = rand::thread_rng();
    let mut particles = Vec::with_capacity(count);

    for _ in 0..count {
        particles.push(Particle {
            x: rng.gen_range(0.0..width as f32),
            y: rng.gen_range(0.0..height as f32),
            dx: rng.gen_range(-1.0..1.0),
            dy: rng.gen_range(-1.0..1.0),
        });
    }

    particles
}

fn main() {
    let mut particles = generate_particles(PARTICLE_COUNT, WIDTH, HEIGHT);
    let mut buffer: Vec<u32> = vec![0; WIDTH * HEIGHT];
    let mut window = Window::new("Safu", WIDTH, HEIGHT, WindowOptions::default())
        .unwrap_or_else(|e| {
            panic!("{}", e);
        });

    let mut mouse_pos = (WIDTH as f32 / 2.0, HEIGHT as f32 / 2.0);
    let mut mouse_pressed = false;
    let friction_per_second = 0.99_f32.powf(60.0);

    let mut last_frame_time = Instant::now();
    let mut frame_count = 0;
    let mut last_fps_time = Instant::now();
    let mut fps = 0;

    while window.is_open() && !window.is_key_down(Key::Escape) {
        let now = Instant::now();
        let delta_time = now.duration_since(last_frame_time).as_secs_f32();
        last_frame_time = now;

        if let Some((mx, my)) = window.get_mouse_pos(minifb::MouseMode::Clamp) {
            mouse_pos = (mx, my);
        }

        mouse_pressed = window.get_mouse_down(MouseButton::Left);
        let dt = delta_time;
        for particle in particles.iter_mut() {
            if mouse_pressed {
                let dx = mouse_pos.0 - particle.x;
                let dy = mouse_pos.1 - particle.y;
                let distance = (dx * dx + dy * dy).sqrt();

                if distance > 0.2 {
                    let inv_gravity = GRAVITY_STRENGTH / distance;
                    particle.dx += dx * inv_gravity * dt;
                    particle.dy += dy * inv_gravity * dt;
                }
            }

            let friction = friction_per_second.powf(dt);
            particle.dx *= friction;
            particle.dy *= friction;
            particle.x += particle.dx * dt;
            particle.y += particle.dy * dt;
        }

        buffer.iter_mut().for_each(|pixel| *pixel = 0);
        for particle in &particles {
            let x = particle.x as usize;
            let y = particle.y as usize;
            let red = (particle.x / WIDTH as f32 * 255.0 * 0.8) as u32;
            let green = (particle.y / HEIGHT as f32 * 255.0 * 0.8) as u32;
            let blue = (255.0*0.5) as u32;
            let color = (red << 16) | (green << 8) | blue;
            let idx = (y.max(0).min(HEIGHT-1) * WIDTH + x.max(0).min(WIDTH-1));
            buffer[idx] = color;
        }

        window.update_with_buffer(&buffer, WIDTH, HEIGHT).unwrap();

        frame_count += 1;
        if now.duration_since(last_fps_time).as_secs_f32() >= 1.0 {
            fps = frame_count;
            frame_count = 0;
            last_fps_time = now;
            
            println!("FPS: {} {}", fps, delta_time);
        }
    }
}