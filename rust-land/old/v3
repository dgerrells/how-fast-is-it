use minifb::{Key, MouseButton, Window, WindowOptions};
use rand::Rng;
use std::mem::MaybeUninit;
use std::time::Instant;
use rayon::prelude::*;

const WIDTH: usize = 1200;
const HEIGHT: usize = 800;
const PARTICLE_COUNT: usize = 20_000_000;
const GRAVITY_STRENGTH: f32 = 200.5;
const MAX_PERF_SAMPLE_FRAMES: usize = 100;

fn main() {
    let mut particles: Box<[MaybeUninit<f32>]> = Box::new_uninit_slice(PARTICLE_COUNT * 4);

    for i in 0..(PARTICLE_COUNT * 4) {
        particles[i].write(0.0);
    }
    let mut particles: Box<[f32]> = unsafe { std::mem::transmute(particles) };

    let mut rng = rand::thread_rng();
    let mut buffer: Vec<u32> = vec![0; WIDTH * HEIGHT];
    let mut window =
        Window::new("Safu", WIDTH, HEIGHT, WindowOptions::default()).unwrap_or_else(|e| {
            panic!("{}", e);
        });
    window.set_target_fps(120);

    let mut i: usize = 0;
    while i < PARTICLE_COUNT {
        let idx = i * 4;
        particles[idx] = rng.gen_range(0.0..WIDTH as f32);
        particles[idx + 1] = rng.gen_range(0.0..HEIGHT as f32);
        particles[idx + 2] = rng.gen_range(-1.0..1.0);
        particles[idx + 3] = rng.gen_range(-1.0..1.0);
        i += 1;
    }

    let mut mouse_pos = (WIDTH as f32 / 2.0, HEIGHT as f32 / 2.0);
    let mut mouse_pressed = false;
    let friction_per_second = 0.99_f32.powf(60.0);

    let mut frame_count = 0;
    let mut last_fps_time = Instant::now();
    let mut last_frame_time = Instant::now();
    let mut simulation_times = vec![];
    let mut drawing_times = vec![];
    let mut fps = 0;

    while window.is_open() && !window.is_key_down(Key::Escape) {
        let now = Instant::now();
        let delta_time = now.duration_since(last_frame_time).as_secs_f32();
        last_frame_time = now;

        let sim_start = Instant::now();

        if let Some((mx, my)) = window.get_mouse_pos(minifb::MouseMode::Clamp) {
            mouse_pos = (mx, my);
        }

        mouse_pressed = window.get_mouse_down(MouseButton::Left);

        particles.par_chunks_mut(4).with_min_len(10000).for_each(|particle| {
            if mouse_pressed {
                let dx = mouse_pos.0 - particle[0];
                let dy = mouse_pos.1 - particle[1];
                let distance = (dx * dx + dy * dy).sqrt();

                if distance > 1.0 {
                    let inv_gravity = GRAVITY_STRENGTH / distance;
                    particle[2] += dx * inv_gravity * 8.0 * delta_time;
                    particle[3] += dy * inv_gravity * 8.0 * delta_time;
                }
            }

            let friction = friction_per_second.powf(delta_time);
            particle[2] *= friction;
            particle[3] *= friction;
            particle[0] += particle[2] * delta_time;
            particle[1] += particle[3] * delta_time;
        });

        simulation_times.push(sim_start.elapsed().as_secs_f32());
        if simulation_times.len() > MAX_PERF_SAMPLE_FRAMES {
            simulation_times.remove(0);
        }

        let draw_start = Instant::now();
        buffer.iter_mut().for_each(|pixel| *pixel = 0);

        for particle in particles.chunks_mut(4) {
            let x = particle[0] as usize;
            let y = particle[1] as usize;
            if x >= WIDTH || y >= HEIGHT || x <= 0 || y <= 0 {
                continue;
            }

            let red = (particle[0] as f32 / WIDTH as f32 * 255.0 * 0.8) as u8;
            let green = (particle[1] as f32 / HEIGHT as f32 * 255.0 * 0.8) as u8;
            let blue = (255.0 * 0.5) as u8;

            let buffer_index = y * WIDTH + x;
            let existing_color = buffer[buffer_index];

            let existing_red = ((existing_color >> 16) & 0xFF) as u8;
            let existing_green = ((existing_color >> 8) & 0xFF) as u8;
            let existing_blue = (existing_color & 0xFF) as u8;
            
            let combined_red = existing_red.saturating_add(red);
            let combined_green = existing_green.saturating_add(green);
            let combined_blue = existing_blue.saturating_add(blue);
            
            let combined_color = ((combined_red as u32) << 16) | ((combined_green as u32) << 8) | (combined_blue as u32);
            buffer[buffer_index] = combined_color;
        }
        window.update_with_buffer(&buffer, WIDTH, HEIGHT).unwrap();

        drawing_times.push(draw_start.elapsed().as_secs_f32());
        if drawing_times.len() > MAX_PERF_SAMPLE_FRAMES {
            drawing_times.remove(0);
        }

        frame_count += 1;
        if now.duration_since(last_fps_time).as_secs_f32() >= 1.0 {
            fps = frame_count;
            frame_count = 0;
            last_fps_time = now;

            let avg_simulation_time: f32 =
                simulation_times.iter().sum::<f32>() / simulation_times.len() as f32;
            let avg_drawing_time: f32 =
                drawing_times.iter().sum::<f32>() / drawing_times.len() as f32;

            println!("FPS: {}", fps);
            println!("Avg Simulation Time: {:.5}", avg_simulation_time * 1000.0);
            println!("Avg Drawing Time: {:.5}", avg_drawing_time * 1000.0);
        }
    }
}
